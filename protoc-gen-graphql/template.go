package main

var goTemplate = `
// Code generated by proroc-gen-graphql, DO NOT EDIT.
package {{ .RootPackage.Name }}

import (
	"context"
	"encoding/json"

	"github.com/graphql-go/graphql"
{{- if .Services }}
	"github.com/ysugimoto/grpc-graphql-gateway/runtime"
	"google.golang.org/grpc"
{{- end }}

{{- range .Packages }}
	{{ .Name }} "{{ .Path }}"
{{ end }}
)

var _ = json.Marshal
var _ = json.Unmarshal

{{ range .Enums -}}
// enum {{ .Name }} in {{ .Filename }}
func Gql__enum_{{ .Name }}() *graphql.Enum {
	return graphql.NewEnum(graphql.EnumConfig{
		Name: "{{ .Name }}",
		Values: graphql.EnumValueConfigMap{
{{- range .Values }}
			"{{ .Name }}": &graphql.EnumValueConfig{
				{{- if .Comment }}
				Description: "{{ .Comment }}",
				{{- end }}
				Value: {{ .Number }},
			},
{{- end }}
		},
	})
}

{{ end }}

{{ range .Interfaces -}}
// message {{ .Name }} in {{ .Filename }}
func gql__interface_{{ .TypeName }}() *graphql.Interface {
	return graphql.NewInterface(graphql.InterfaceConfig{
		Name: "{{ .TypeName }}Interface",
		{{- if .Comment }}
		Description: "{{ .Comment }}",
		{{- end }}
		Fields: graphql.Fields{
{{- range .Fields }}
		{{- if not .IsCyclic }}
			"{{ .Name }}": &graphql.Field{
				Type: {{ .FieldType $.RootPackage.Path }},
				{{- if .Comment }}
				Description: "{{ .Comment }}",
				{{- end }}
			},
		{{- end }}
{{- end }}
		},
		ResolveType: func(p graphql.ResolveTypeParams) *graphql.Object {
			return Gql__type_{{ .TypeName }}()
		},
	})
}

{{ end }}

{{ range .Types -}}
// message {{ .Name }} in {{ .Filename }}
func Gql__type_{{ .TypeName }}() *graphql.Object {
	return graphql.NewObject(graphql.ObjectConfig{
		Name: "{{ .TypeName }}",
		{{- if .Comment }}
		Description: "{{ .Comment }}",
		{{- end }}
		Fields: graphql.Fields {
{{- range .Fields }}
			"{{ .Name }}": &graphql.Field{
				Type: {{ .FieldType $.RootPackage.Path }},
				{{- if .Comment }}
				Description: "{{ .Comment }}",
				{{- end }}
			},
{{- end }}
		},
		{{- if .Interfaces }}
		Interfaces: []*graphql.Interface{
{{- range .Interfaces }}
		 gql__interface_{{ .TypeName }}(),
{{- end }}
		},
		{{- end }}
	})
}

{{ end }}

{{ range .Inputs -}}
// message {{ .Name }} in {{ .Filename }}
func Gql__input_{{ .TypeName }}() *graphql.InputObject {
	return graphql.NewInputObject(graphql.InputObjectConfig{
		Name: "{{ .TypeName }}",
		Fields: graphql.InputObjectConfigFieldMap{
{{- range .Fields }}
			"{{ .Name }}": &graphql.InputObjectFieldConfig{
				{{- if .Comment }}
				Description: "{{ .Comment }}",
				{{- end }}
				Type: {{ .FieldTypeInput $.RootPackage.Path }},
			},
{{- end }}
		},
	})
}

{{ end }}

{{ range $_, $service := .Services -}}
// graphql__resolver_{{ $service.Name }} is a struct for making query, mutation and resolve fields.
// This struct must be implemented runtime.SchemaBuilder interface.
type graphql__resolver_{{ $service.Name }} struct {

	// Automatic connection host
	host string

	// grpc dial options
	dialOptions []grpc.DialOption

	// grpc client connection.
	// this connection may be provided by user
	conn *grpc.ClientConn
}

// CreateConnection() returns grpc connection which user specified or newly connected and closing function
func (x *graphql__resolver_{{ $service.Name }}) CreateConnection(ctx context.Context) (*grpc.ClientConn, func(), error) {
	// If x.conn is not nil, user injected their own connection
	if x.conn != nil {
		return x.conn, func() {}, nil
	}

	// Otherwise, this handler opens connection with specified host
	conn, err := grpc.DialContext(ctx, x.host, x.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	return conn, func() { conn.Close() }, nil
}

// GetQueries returns acceptable graphql.Fields for Query.
func (x *graphql__resolver_{{ $service.Name }}) GetQueries(conn *grpc.ClientConn) graphql.Fields {
	return graphql.Fields{
{{- range .Queries }}
		"{{ .QueryName }}": &graphql.Field{
			Type: {{ .QueryType }},
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{- end }}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldType $.RootPackage.Path }},
					{{- if .Comment }}
					Description: "{{ .Comment }}",
					{{- end }}
					{{- if .DefaultValue }}
					DefaultValue: {{ .DefaultValue }},
					{{- end }}
				},
			{{- end }}
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .InputType }}
				if err := runtime.MarshalRequest(p.Args, &req); err != nil {
					return nil, err
				}
				client := {{ .Package }}New{{ $service.Name }}Client(conn)
				resp, err := client.{{ .Method.Name }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{- if .IsPluckResponse }}
				return resp.Get{{ .PluckResponseFieldName }}(), nil
				{{- else }}
				return resp, nil
				{{- end }}
			},
		},
{{- end }}
	}
}

// GetMutations returns acceptable graphql.Fields for Mutation.
func (x *graphql__resolver_{{ $service.Name }}) GetMutations(conn *grpc.ClientConn) graphql.Fields {
	return graphql.Fields{
{{- range .Mutations }}
		"{{ .MutationName }}": &graphql.Field{
			Type: {{ .MutationType }},
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{ end }}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldTypeInput $.RootPackage.Path }},
					{{- if .Comment }}
					Description: "{{ .Comment }}",
					{{- end }}
					{{- if .DefaultValue }}
					DefaultValue: {{ .DefaultValue }},
					{{- end }}
				},
			{{- end }}
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .InputType }}
				if err := runtime.MarshalRequest(p.Args, &req); err != nil {
					return nil, err
				}
				client := {{ .Package }}New{{ $service.Name }}Client(conn)
				resp, err := client.{{ .Method.Name }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{- if .IsPluckResponse }}
				return resp.Get{{ .PluckResponseFieldName }}(), nil
				{{- else }}
				return resp, nil
				{{- end }}
			},
		},
{{ end }}
	}
}

// Register package divided graphql handler "without" *grpc.ClientConn,
// therefore gRPC connection will be opened and closed automatically.
// Occasionally you may worry about open/close performance for each handling graphql request,
// then you can call Register{{ .Name }}GraphqlHandler with *grpc.ClientConn manually.
func Register{{ .Name }}Graphql(mux *runtime.ServeMux) {
	Register{{ .Name }}GraphqlHandler(mux, nil)
}

// Register package divided graphql handler "with" *grpc.ClientConn.
// this function accepts your defined grpc connection, so that we reuse that and never close connection inside.
// You need to close it maunally when application will terminate.
// Otherwise, you can specify automatic opening connection with ServiceOption directive:
//
// service {{ .Name }} {
//    option (graphql.service) = {
//        host: "host:port"
//        insecure: true or false
//    };
//
//    ...with RPC definitions
// }
func Register{{ .Name }}GraphqlHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) {
	mux.AddHandler(&graphql__resolver_{{ .Name }}{
		conn: conn,
		host: "{{ if .Host }}{{ .Host }}{{ else }}localhost:50051{{ end }}",
		dialOptions: []grpc.DialOption{
		{{- if .Insecure }}
			grpc.WithInsecure(),
		{{- end }}
		},
	})
}

{{ end }}
`
