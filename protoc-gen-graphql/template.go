package main

var goTemplate = `
// Code generated by proroc-gen-graphql, DO NOT EDIT.
package {{ .RootPackage.Name }}

import (
	"encoding/json"

	"github.com/graphql-go/graphql"
{{- if .Services }}
	"github.com/ysugimoto/grpc-graphql-gateway/runtime"
	"google.golang.org/grpc"
{{- end }}

{{- range .Packages }}
	{{ .Name }} "{{ .Path }}"
{{ end }}
)

var _ = json.Marshal
var _ = json.Unmarshal

// Graphql related variables declaration
var (
{{ range .Enums -}}
Gql__enum_{{ .Name }} *graphql.Enum
{{ end }}
{{ range .Interfaces -}}
gql__interface_{{ .TypeName }} *graphql.Interface
{{ end }}
{{ range .Types -}}
Gql__type_{{ .TypeName }} *graphql.Object
{{ end }}
{{ range .Inputs -}}
Gql__input_{{ .TypeName }} *graphql.InputObject
{{ end }}
)

// We need to initialize any values inside init()
// because some message may have cyclic dependencies like:
//
// message Person {
//    // the Person has repeated Person. this is valid on protobuf.
//    repeated Person friends = 1;
// }
//
// Then we generates code which has same type in its field,
// But Go runtime panics with typecheking loop.
// In order to avoid it, firstly we only define variables and lazy assign it inside init().
func init() {
{{ range .Enums -}}
Gql__enum_{{ .Name }} = graphql.NewEnum(graphql.EnumConfig{
	Name: "{{ .Name }}",
	Values: graphql.EnumValueConfigMap{
{{- range .Values }}
		"{{ .Name }}": &graphql.EnumValueConfig{
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{- end }}
			Value: {{ .Number }},
		},
{{- end }}
	},
}) // enum {{ .Name }} in {{ .Filename }}
{{ end }}

{{ range .Interfaces -}}
gql__interface_{{ .TypeName }} = graphql.NewInterface(graphql.InterfaceConfig{
	Name: "{{ .TypeName }}",
	{{- if .Comment }}
	Description: "{{ .Comment }}",
	{{- end }}
	ResolveType: func(p graphql.ResolveTypeParams) *graphql.Object {
		return Gql__type_{{ .TypeName }}
	},
})
{{ end }}

{{ range .Types -}}
Gql__type_{{ .TypeName }} = graphql.NewObject(graphql.ObjectConfig{
	Name: "{{ .TypeName }}",
	{{- if .Comment }}
	Description: "{{ .Comment }}",
	{{- end }}
	Fields: graphql.Fields {
{{- range .Fields }}
		"{{ .Name }}": &graphql.Field{
			Type: {{ .FieldType $.RootPackage.Path }},
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{- end }}
		},
{{- end }}
	},
	{{- if .Interfaces }}
	Interfaces: []*graphql.Interface{
{{- range .Interfaces }}
	  gql__interface_{{ .TypeName }},
{{- end }}
	},
	{{- end }}
}) // message {{ .Name }} in {{ .Filename }}

{{ end }}

{{ range .Inputs -}}
Gql__input_{{ .TypeName }} = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "{{ .TypeName }}",
	Fields: graphql.InputObjectConfigFieldMap{
{{- range .Fields }}
		"{{ .Name }}": &graphql.InputObjectFieldConfig{
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{- end }}
			Type: {{ .FieldTypeInput $.RootPackage.Path }},
		},
{{- end }}
	},
}) // message {{ .Name }} in {{ .Filename }}

{{ end }}
}

{{ range $_, $service := .Services -}}
// graphql__resolver_{{ $service.Name }} is a struct for making query, mutation and resolve fields.
// This struct must be implemented runtime.SchemaBuilder interface.
type graphql__resolver_{{ $service.Name }} struct {
	// grpc client connection.
	// this connection may be provided by user, then isAutoConnection should be false
	conn *grpc.ClientConn

	// isAutoConnection indicates that the grpc connection is opened by this handler.
	// If true, this handler opens connection automatically, and it should be closed on Close() method.
	isAutoConnection bool
}

// Close() closes grpc connection if it is opened automatically.
func (x *graphql__resolver_{{ $service.Name }}) Close() error {
	// nothing to do because the connection is supplied by user, and it should be closed user themselves.
	if !x.isAutoConnection {
		return nil
	}
	return x.conn.Close()
}

// GetQueries returns acceptable graphql.Fields for Query.
func (x *graphql__resolver_{{ $service.Name }}) GetQueries() graphql.Fields {
	return graphql.Fields{
{{- range .Queries }}
		"{{ .QueryName }}": &graphql.Field{
			Type: {{ .QueryType }},
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{- end }}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldType $.RootPackage.Path }},
					{{- if .Comment }}
					Description: "{{ .Comment }}",
					{{- end }}
					{{- if .DefaultValue }}
					DefaultValue: {{ .DefaultValue }},
					{{- end }}
				},
			{{- end }}
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .InputType }}
				if err := runtime.MarshalRequest(p.Args, &req); err != nil {
					return nil, err
				}
				client := {{ .Package }}New{{ $service.Name }}Client(x.conn)
				resp, err := client.{{ .Method.Name }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{- if .IsPluckResponse }}
				return resp.Get{{ .PluckResponseFieldName }}(), nil
				{{- else }}
				return resp, nil
				{{- end }}
			},
		},
{{- end }}
	}
}

// GetMutations returns acceptable graphql.Fields for Mutation.
func (x *graphql__resolver_{{ $service.Name }}) GetMutations() graphql.Fields {
	return graphql.Fields{
{{- range .Mutations }}
		"{{ .MutationName }}": &graphql.Field{
			Type: {{ .MutationType }},
			{{- if .Comment }}
			Description: "{{ .Comment }}",
			{{ end }}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldTypeInput $.RootPackage.Path }},
					{{- if .Comment }}
					Description: "{{ .Comment }}",
					{{- end }}
					{{- if .DefaultValue }}
					DefaultValue: {{ .DefaultValue }},
					{{- end }}
				},
			{{- end }}
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .InputType }}
				if err := runtime.MarshalRequest(p.Args, &req); err != nil {
					return nil, err
				}
				client := {{ .Package }}New{{ $service.Name }}Client(x.conn)
				resp, err := client.{{ .Method.Name }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{- if .IsPluckResponse }}
				return resp.Get{{ .PluckResponseFieldName }}(), nil
				{{- else }}
				return resp, nil
				{{- end }}
			},
		},
{{ end }}
	}
}

// Register package divided graphql handler "without" *grpc.ClientConn,
// therefore gRPC connection will be opened and closed automatically.
// Occasionally you may worry about open/close performance for each handling graphql request,
// then you can call Register{{ .Name }}GraphqlHandler with *grpc.ClientConn manually.
func Register{{ .Name }}Graphql(mux *runtime.ServeMux) error {
	return Register{{ .Name }}GraphqlHandler(mux, nil)
}

// Register package divided graphql handler "with" *grpc.ClientConn.
// this function accepts your defined grpc connection, so that we reuse that and never close connection inside.
// You need to close it maunally when application will terminate.
// Otherwise, the resolver opens connection automatically and then you need to define host with FileOption like:
//
// service {{ .Name }} {
//    option (graphql.service) = {
//        host: "your default host like localhost:50051";
//        insecure: true or false;
//    };
//
//    ...with RPC definitions
// }
//
func Register{{ .Name }}GraphqlHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) (err error) {
	var isAutoConnection bool
	if conn == nil {
		isAutoConnection = true
		conn, err = grpc.Dial("{{ if .Host }}{{ .Host }}{{ else }}localhost:50051{{ end }}"{{ if .Insecure }}, grpc.WithInsecure(){{ end }})
		if err != nil {
			return
		}
	}
	mux.AddHandler(&graphql__resolver_{{ .Name }}{conn, isAutoConnection})
	return
}
{{ end }}
`
