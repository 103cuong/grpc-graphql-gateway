package generator

import (
	"bytes"
	"fmt"

	"go/format"
	"text/template"

	"github.com/golang/protobuf/proto"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/ysugimoto/grpc-graphql-gateway/protoc-gen-graphql/builder"
	"github.com/ysugimoto/grpc-graphql-gateway/protoc-gen-graphql/resolver"
	"github.com/ysugimoto/grpc-graphql-gateway/protoc-gen-graphql/spec"
)

// Program generator is used for generating Go code.
type Program struct {
	RootPackage *spec.Package
	Service     *spec.Service

	Packages  []*spec.Package
	Types     []*spec.Message
	Enums     []*spec.Enum
	Inputs    []*spec.Message
	Queries   []*spec.Query
	Mutations []*spec.Mutation

	qs []*spec.Method
	ms []*spec.Method
}

func NewProgram(
	pkgName string,
	qs, ms []*spec.Method,
) *Program {
	return &Program{
		RootPackage: spec.NewPackage(pkgName),
		Queries:     make([]*spec.Query, 0),
		Mutations:   make([]*spec.Mutation, 0),
		Packages:    make([]*spec.Package, 0),
		Types:       make([]*spec.Message, 0),
		Enums:       make([]*spec.Enum, 0),
		Inputs:      make([]*spec.Message, 0),
		qs:          qs,
		ms:          ms,
	}
}

func (p *Program) Generate(r *resolver.Resolver) (*plugin.CodeGeneratorResponse_File, error) {
	if err := p.generateTemplateParams(r); err != nil {
		return nil, err
	}

	buf := new(bytes.Buffer)
	if t, err := template.New("program").Parse(programTemplate); err != nil {
		return nil, err
	} else if err := t.Execute(buf, p); err != nil {
		return nil, err
	}

	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return &plugin.CodeGeneratorResponse_File{
		Name: proto.String(fmt.Sprintf(
			"%s/%s.graphql.go",
			p.RootPackage.Path,
			p.RootPackage.Name,
		)),
		Content: proto.String(string(out)),
	}, nil
}

func (p *Program) generateTemplateParams(r *resolver.Resolver) (err error) {
	var pkgs []*spec.Package
	p.Types, p.Enums, p.Inputs, pkgs, err = r.ResolveTypes(p.Queries, p.Mutations)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		if pkg.Path == p.RootPackage.Path {
			continue
		}
		p.Packages = append(p.Packages, pkg)
	}

	if len(p.Queries) > 0 {
		p.Service = p.Queries[0].Service
	} else if len(p.Mutations) > 0 {
		p.Service = p.Mutations[0].Service
	}

	return nil
}

var programTemplate = `
// Code generated by proroc-gen-graphql, DO NOT EDIT.
package {{ .RootPackage.Name }}

import (
	"encoding/json"

	"github.com/graphql-go/graphql"
	"github.com/ysugimoto/grpc-graphql-gateway/runtime"
	"google.golang.org/grpc"

{{ range .Packages }}
	{{ .Name }} "{{ .Path }}"
{{ end }}
)

var _ = json.Marshal
var _ = json.Unmarshal

{{ range .Types -}}
var gql__type_{{ .Name }} = graphql.NewObject(graphql.ObjectConfig{
	Name: "{{ .Name }}",
	Fields: graphql.Field {
{{ range .Fields }}
		{{ if .Comment 1 -}}
		Description: "{{ .Comment }}",
		{{ end }}
		"{{ .Name }}": &graphql.Field{
			Type: {{ .FieldType }},
		},
{{ end }}
	},
}) // message {{ .Name }} in {{ .Filename }}
{{ end }}

{{ range .Enums -}}
var gql__enum_{{ .Name }} = graphql.NewEnum(graphql.EnumConfig{
	Name: "{{ .Name }}",
	Values: graphql.EnumValueConfigMap{
{{ range .Values }}
		"{{ .Name }}": &graphql.EnumValueConfig{
			Value: {{ .Number }},
		},
{{ end }}
	},
}) // enum {{ .Name }} in {{ .Filename }}
{{ end }}

{{ range .Inputs -}}
var gql__input_{{ .Name }} = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "{{ .Name }}",
	Fields: graphql.InputObjectConfigFieldMap{
{{ range .Fields }}
		"{{ .Name }}": &graphql.InputObjectFieldConfig{
			{{ if .Comment -}}
			Description: "{{ .Comment }}",
			{{ end }}
			Type: {{ .FieldType }},
		},
{{ end }}
	},
}) // message {{ .Name }} in {{ .Filename }}
{{ end }}

// gql__resolver_{{ .Service.Name }} is a struct for making query, mutation and resolve fields.
// This struct must be implemented runtime.Resolver interface.
type gql__resolver_{{ .Service.Name }} struct {
	conn *grpc.ClientConn
}

// GetQueries returns acceptable graphql.Fields for Query.
func (x *gql__resolver_{{ .Service.Name }}) GetQueries() graphql.Fields {
	return graphql.Fields{
{{ range .Queries }}
		"{{ .Name }}": &graphql.Field{
			Type: {{ .FieldType }},
			{{ if .Comment -}}
			Description: "{{ .Comment }}",
			{{ end }}
			{{- if .Args -}}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				{{ .Comment }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldType }},
				},
			},
			{{- end -}}
			{{- end -}}
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return nil, nil
			},
		},
{{ end }}
}

// GetMutations returns acceptable graphql.Fields for Mutation.
func (x *gql__resolver_{{ .Service.Name }}) GetMutations() graphql.Fields {
	return graphql.Fields{
{{ range .Mutations }}
		"{{ .Name }}": &graphql.Field{
			Type: {{ .FieldType }},
			{{ if .Comment -}}
			Description: "{{ .Comment }}",
			{{ end }}
			{{- if .Args -}}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				{{ .Comment }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldType }},
				},
			},
			{{- end -}}
			{{- end -}}
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .RequestType }}
				if err := runtime.MarshalRequest(p.Args, req); err != nil {
					return nil, err
				}
				client, err := {{ .Package }}New{{ .Service.Name }}Client(x.conn)
				resp, err := client.{{ .Method }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{ if .Expose }}
				return resp{{ .Expose }}(), nil
				{{ else }}
				return resp, nil
				{{ end }}
			},
		},
{{ end }}
	},
}

// Register package divided graphql handler "without" *grpc.ClientConn,
// therefore gRPC connection will be opened and closed automatically.
// Occasionally you worried about open/close performance for each handling graphql request,
// then you can call RegisterBookHandler with *grpc.ClientConn manually.
func RegisterBookGraphql(mux *runtime.ServeMux) error {
	RegisterBookGraphqlHandler(mux, nil)
}

// Register package divided graphql handler "with" *grpc.ClientConn.
// this function accepts your defined grpc connection, so that we reuse that and never close connection inside.
// You need to close it maunally when appication will terminate.
// Otherwise, the resolver opens connection automatically, but then you need to define host with ServiceOption like:
// service XXXService {
//    option (graphql.service) = {
//        host: "localhost:50051"
//    };
//
//    ...with RPC definitions
// }
func RegisterBookGraphqlHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) (err error) {
	if conn == nil {
		conn, err = grpc.Dial("{{ .Service.Host }}"{{ if .Service.Insecure }}, grpc.WithInsecure(){{ end }})
		if err != nil {
			return err
		}
	}
	mux.AddHandler(&gql__resolver_{{ .Service.Name }}{conn})
}`
