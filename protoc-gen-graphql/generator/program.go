package generator

import (
	"bytes"
	"fmt"

	"go/format"
	"io/ioutil"
	"text/template"

	"github.com/golang/protobuf/proto"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/ysugimoto/grpc-graphql-gateway/protoc-gen-graphql/resolver"
	"github.com/ysugimoto/grpc-graphql-gateway/protoc-gen-graphql/spec"
)

// Program generator is used for generating Go code.
type Program struct {
	RootPackage *spec.Package
	Service     *spec.Service

	Packages  []*spec.Package
	Types     []*spec.Message
	Enums     []*spec.Enum
	Inputs    []*spec.Message
	Queries   []*spec.Query
	Mutations []*spec.Mutation
}

func NewProgram(pkgName string) *Program {
	return &Program{
		RootPackage: spec.NewPackage(pkgName),
		Queries:     make([]*spec.Query, 0),
		Mutations:   make([]*spec.Mutation, 0),
		Packages:    make([]*spec.Package, 0),
		Types:       make([]*spec.Message, 0),
		Enums:       make([]*spec.Enum, 0),
		Inputs:      make([]*spec.Message, 0),
	}
}

func (p *Program) Generate(
	r *resolver.Resolver,
	qs, ms []*spec.Method,
) (*plugin.CodeGeneratorResponse_File, error) {
	if err := p.generateTemplateParams(r, qs, ms); err != nil {
		return nil, err
	}

	buf := new(bytes.Buffer)
	if t, err := template.New("program").Parse(programTemplate); err != nil {
		return nil, err
	} else if err := t.Execute(buf, p); err != nil {
		return nil, err
	}

	ioutil.WriteFile("/tmp/"+p.RootPackage.Name+".go", buf.Bytes(), 0666)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return &plugin.CodeGeneratorResponse_File{
		Name: proto.String(fmt.Sprintf(
			"%s/%s.graphql.go",
			p.RootPackage.Path,
			p.RootPackage.Name,
		)),
		Content: proto.String(string(out)),
	}, nil
}

func (p *Program) generateTemplateParams(
	r *resolver.Resolver,
	qs, ms []*spec.Method,
) (err error) {
	var pkgs []*spec.Package
	p.Types, p.Enums, p.Inputs, pkgs, err = r.ResolveTypes(qs, ms)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		if pkg.Path == p.RootPackage.Path {
			continue
		}
		p.Packages = append(p.Packages, pkg)
	}

	if len(qs) > 0 {
		m := qs[0]
		p.Service = m.Service
	} else if len(ms) > 0 {
		m := ms[0]
		p.Service = m.Service
	}

	for _, q := range qs {
		p.Queries = append(p.Queries, spec.NewQuery(
			q,
			r.Find(q.Input()),
			r.Find(q.Output()),
		))
	}

	for _, m := range ms {
		p.Mutations = append(p.Mutations, spec.NewMutation(
			m,
			r.Find(m.Input()),
			r.Find(m.Output()),
		))
	}

	return nil
}

var programTemplate = `
// Code generated by proroc-gen-graphql, DO NOT EDIT.
package {{ .RootPackage.Name }}

import (
	"encoding/json"

	"github.com/graphql-go/graphql"
	"github.com/ysugimoto/grpc-graphql-gateway/runtime"
	"google.golang.org/grpc"

{{- range .Packages }}
	{{ .Name }} "{{ .Path }}"
{{ end }}
)

var _ = json.Marshal
var _ = json.Unmarshal

{{ range .Types -}}
var gql__type_{{ .Name }} = graphql.NewObject(graphql.ObjectConfig{
	Name: "{{ .Name }}",
	Fields: graphql.Fields {
{{- range .Fields }}
		"{{ .Name }}": &graphql.Field{
			Type: {{ .FieldType }},
			{{- if .Comment 1 }}
			Description: "{{ .Comment 1 }}",
			{{- end }}
		},
{{- end }}
	},
}) // message {{ .Name }} in {{ .Filename }}

{{ end }}

{{ range .Enums -}}
var gql__enum_{{ .Name }} = graphql.NewEnum(graphql.EnumConfig{
	Name: "{{ .Name }}",
	Values: graphql.EnumValueConfigMap{
{{- range .Values }}
		"{{ .Name }}": &graphql.EnumValueConfig{
			{{- if .Comment 1 }}
			Description: "{{ .Comment 1 }}",
			{{- end }}
			Value: {{ .Number }},
		},
{{- end }}
	},
}) // enum {{ .Name }} in {{ .Filename }}
{{ end }}

{{ range .Inputs -}}
var gql__input_{{ .Name }} = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "{{ .Name }}",
	Fields: graphql.InputObjectConfigFieldMap{
{{- range .Fields }}
		"{{ .Name }}": &graphql.InputObjectFieldConfig{
			{{- if .Comment 1 }}
			Description: "{{ .Comment 1 }}",
			{{- end }}
			Type: {{ .FieldType }},
		},
{{- end }}
	},
}) // message {{ .Name }} in {{ .Filename }}
{{ end }}

// gql__resolver_{{ .Service.Name }} is a struct for making query, mutation and resolve fields.
// This struct must be implemented runtime.Resolver interface.
type gql__resolver_{{ .Service.Name }} struct {
	conn *grpc.ClientConn
}

// GetQueries returns acceptable graphql.Fields for Query.
func (x *gql__resolver_{{ .Service.Name }}) GetQueries() graphql.Fields {
	return graphql.Fields{
{{- range .Queries }}
		"{{ .QueryName }}": &graphql.Field{
			Type: {{ .QueryType }},
			{{- if .Comment 1 -}}
			Description: "{{ .Comment 1 }}",
			{{- end }}
			{{- if .Args }}
			Args: graphql.FieldConfigArgument{
			{{- range .Args }}
				"{{ .Name }}": &graphql.ArgumentConfig{
					Type: {{ .FieldType }},
					{{- if .Comment 1 }}
					Description: "{{ .Comment 1 }}",
					{{- end }}
				},
			{{- end }}
			},
			{{- end }}
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return nil, nil
			},
		},
{{- end }}
	}
}

// GetMutations returns acceptable graphql.Fields for Mutation.
func (x *gql__resolver_{{ .Service.Name }}) GetMutations() graphql.Fields {
	return graphql.Fields{
{{- range .Mutations }}
		"{{ .MutationName }}": &graphql.Field{
			Type: {{ .MutationType }},
			{{- if .Comment 1 -}}
			Description: "{{ .Comment 1 }}",
			{{ end }}
			Args: graphql.FieldConfigArgument{
				"{{ .InputName }}": &graphql.ArgumentConfig{
					Type: gql__input_{{ .Input.Name }},
				},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				var req *{{ .RequestType }}
				if err := runtime.MarshalRequest(p.Args, req); err != nil {
					return nil, err
				}
				client := {{ .Package }}New{{ .Service.Name }}Client(x.conn)
				resp, err := client.{{ .Method.Name }}(p.Context, req)
				if err != nil {
					return nil, err
				}
				{{- if .Expose }}
				return resp.Get{{ .Expose }}(), nil
				{{- else }}
				return resp, nil
				{{- end }}
			},
		},
{{ end }}
	}
}

// Register package divided graphql handler "without" *grpc.ClientConn,
// therefore gRPC connection will be opened and closed automatically.
// Occasionally you worried about open/close performance for each handling graphql request,
// then you can call RegisterBookHandler with *grpc.ClientConn manually.
func RegisterBookGraphql(mux *runtime.ServeMux) error {
	return RegisterBookGraphqlHandler(mux, nil)
}

// Register package divided graphql handler "with" *grpc.ClientConn.
// this function accepts your defined grpc connection, so that we reuse that and never close connection inside.
// You need to close it maunally when appication will terminate.
// Otherwise, the resolver opens connection automatically, but then you need to define host with ServiceOption like:
//
// service XXXService {
//    option (graphql.service) = {
//        host: "localhost:50051"
//    };
//
//    ...with RPC definitions
// }
func RegisterBookGraphqlHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) (err error) {
	if conn == nil {
		conn, err = grpc.Dial("{{ .Service.Host }}"{{ if .Service.Insecure }}, grpc.WithInsecure(){{ end }})
		if err != nil {
			return
		}
	}
	mux.AddHandler(&gql__resolver_{{ .Service.Name }}{conn})
	return
}`
